# -*- coding: utf-8 -*-
"""Recipe Generator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JAHyHeewZJLhDZSQj2tAw61-yt0O839M
"""

# =========================
# üç≥ Recipe Builder RAG ‚Äî Launcher
# =========================

# 1) Install deps
!pip -q install streamlit langchain-community faiss-cpu sentence-transformers \
                transformers accelerate safetensors > /dev/null

# 2) Write the Streamlit app
app_code = """
import torch
import streamlit as st
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from langchain.text_splitter import RecursiveCharacterTextSplitter
from transformers import AutoTokenizer, AutoModelForSeq2SeqLM

st.set_page_config(page_title="Recipe Builder", page_icon="üç≥")
st.title("üç≥ AI Recipe Builder with Shopping List")

st.markdown(
    "Enter the ingredients you have, and I'll suggest recipes you can make "
    "plus a shopping list for any missing items!"
)

# ---------------------------
# RECIPE DATABASE
# ---------------------------
RECIPE_DB = '''
Recipe: Classic Spaghetti Carbonara
Ingredients: spaghetti, eggs, parmesan cheese, bacon, black pepper, salt
Instructions: Cook spaghetti. Fry bacon until crispy. Mix eggs with parmesan. Combine hot pasta with bacon, then stir in egg mixture off heat. Season with pepper.
Category: Italian, Pasta, Quick
Servings: 4

Recipe: Chicken Stir Fry
Ingredients: chicken breast, soy sauce, garlic, ginger, bell peppers, onion, vegetable oil, rice
Instructions: Cut chicken into strips. Heat oil, cook chicken until golden. Add garlic, ginger, peppers, and onion. Stir fry 5 minutes. Add soy sauce. Serve over rice.
Category: Asian, Quick, Healthy
Servings: 4

Recipe: Vegetable Curry
Ingredients: potatoes, carrots, onion, garlic, curry powder, coconut milk, chickpeas, vegetable oil, rice
Instructions: Saut√© onion and garlic. Add curry powder, then vegetables. Pour in coconut milk and simmer 20 minutes. Add chickpeas, cook 5 more minutes. Serve with rice.
Category: Indian, Vegetarian, Comfort
Servings: 6

Recipe: Caesar Salad
Ingredients: romaine lettuce, parmesan cheese, croutons, caesar dressing, lemon juice, black pepper
Instructions: Tear lettuce into bite-sized pieces. Toss with caesar dressing. Top with parmesan and croutons. Add lemon juice and pepper to taste.
Category: Salad, Quick, Light
Servings: 2

Recipe: Beef Tacos
Ingredients: ground beef, taco shells, lettuce, tomatoes, cheese, sour cream, onion, taco seasoning
Instructions: Brown beef with taco seasoning. Warm taco shells. Fill with beef, lettuce, tomatoes, cheese, onion, and sour cream.
Category: Mexican, Quick, Family
Servings: 4

Recipe: Mushroom Risotto
Ingredients: arborio rice, mushrooms, onion, garlic, white wine, parmesan cheese, butter, chicken broth
Instructions: Saut√© mushrooms, set aside. Cook onion and garlic, add rice. Add wine, then broth gradually while stirring. Finish with mushrooms, butter, and parmesan.
Category: Italian, Comfort, Elegant
Servings: 4

Recipe: Greek Salad
Ingredients: tomatoes, cucumber, red onion, feta cheese, olives, olive oil, lemon juice, oregano
Instructions: Chop tomatoes and cucumber. Slice onion. Combine vegetables with olives and feta. Dress with olive oil, lemon juice, and oregano.
Category: Greek, Salad, Healthy
Servings: 4

Recipe: Pancakes
Ingredients: flour, eggs, milk, sugar, baking powder, butter, salt
Instructions: Mix dry ingredients. Whisk in eggs and milk. Heat butter in pan. Pour batter and cook until bubbles form. Flip and cook until golden.
Category: Breakfast, Quick, Sweet
Servings: 4

Recipe: Tomato Soup
Ingredients: tomatoes, onion, garlic, vegetable broth, cream, olive oil, basil, salt, black pepper
Instructions: Saut√© onion and garlic. Add tomatoes and broth, simmer 20 minutes. Blend until smooth. Stir in cream and basil. Season to taste.
Category: Soup, Comfort, Vegetarian
Servings: 4

Recipe: Chicken Parmesan
Ingredients: chicken breast, breadcrumbs, parmesan cheese, mozzarella cheese, eggs, tomato sauce, spaghetti, olive oil
Instructions: Bread chicken with egg and breadcrumbs mixed with parmesan. Fry until golden. Top with tomato sauce and mozzarella, bake until melted. Serve over spaghetti.
Category: Italian, Comfort, Family
Servings: 4

Recipe: Fried Rice
Ingredients: rice, eggs, soy sauce, garlic, peas, carrots, onion, vegetable oil
Instructions: Cook rice and cool. Heat oil, scramble eggs, set aside. Stir fry vegetables. Add rice, soy sauce, and eggs. Toss until heated through.
Category: Asian, Quick, Leftover-Friendly
Servings: 4

Recipe: Caprese Salad
Ingredients: tomatoes, mozzarella cheese, basil, olive oil, balsamic vinegar, salt, black pepper
Instructions: Slice tomatoes and mozzarella. Arrange alternating slices with basil leaves. Drizzle with olive oil and balsamic vinegar. Season with salt and pepper.
Category: Italian, Salad, Quick
Servings: 2
'''

# ---------------------------
# CACHED MODELS
# ---------------------------
@st.cache_resource
def load_embeddings():
    return HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")

@st.cache_resource
def load_flan():
    name = "google/flan-t5-base"
    tok = AutoTokenizer.from_pretrained(name)
    dtype = torch.float16 if torch.cuda.is_available() else torch.float32
    model = AutoModelForSeq2SeqLM.from_pretrained(name, torch_dtype=dtype)
    device = "cuda" if torch.cuda.is_available() else "cpu"
    model.to(device)
    return tok, model, device

@st.cache_resource
def build_recipe_vectorstore():
    embeddings = load_embeddings()
    splitter = RecursiveCharacterTextSplitter(
        chunk_size=500,
        chunk_overlap=50,
        separators=["\\n\\nRecipe:", "\\n"],
    )
    docs = splitter.create_documents([RECIPE_DB])
    return FAISS.from_documents(docs, embeddings)

embeddings = load_embeddings()
tokenizer, flan, device = load_flan()
vectorstore = build_recipe_vectorstore()

# ---------------------------
# HELPERS
# ---------------------------
def parse_ingredients(user_input):
    ingredients = [i.strip().lower() for i in user_input.replace("\\n", ",").split(",")]
    return [i for i in ingredients if i]

def extract_recipe_details(recipe_text):
    lines = recipe_text.strip().split("\\n")
    recipe = {"name": "", "ingredients": [], "instructions": "", "servings": ""}

    for line in lines:
        if line.startswith("Recipe:"):
            recipe["name"] = line.replace("Recipe:", "").strip()
        elif line.startswith("Ingredients:"):
            ingredients = line.replace("Ingredients:", "").strip()
            recipe["ingredients"] = [i.strip() for i in ingredients.split(",")]
        elif line.startswith("Instructions:"):
            recipe["instructions"] = line.replace("Instructions:", "").strip()
        elif line.startswith("Servings:"):
            recipe["servings"] = line.replace("Servings:", "").strip()

    return recipe

def calculate_missing_ingredients(user_ingredients, recipe_ingredients):
    user_set = set(user_ingredients)
    missing = []

    for ingredient in recipe_ingredients:
        ingredient_lower = ingredient.lower()
        if not any(user_ing in ingredient_lower or ingredient_lower in user_ing
                   for user_ing in user_set):
            missing.append(ingredient)

    return missing

def generate_with_flan(prompt, max_tokens=256):
    inputs = tokenizer(prompt, return_tensors="pt", truncation=True, max_length=512).to(device)
    with torch.no_grad():
        output = flan.generate(
            **inputs,
            max_new_tokens=max_tokens,
            temperature=0.7,
            do_sample=True,
            top_p=0.9,
            repetition_penalty=1.5,
        )
    return tokenizer.decode(output[0], skip_special_tokens=True)

# ---------------------------
# UI
# ---------------------------
st.subheader("üìù Enter Your Ingredients")

user_input = st.text_area(
    "List the ingredients you have (comma or line separated)",
    placeholder="e.g., chicken, rice, onion, garlic, soy sauce",
    height=100
)

num_recipes = st.slider("Number of recipes to generate", 3, 6, 3)

if st.button("üîç Find Recipes", type="primary"):
    if not user_input.strip():
        st.warning("Please enter at least one ingredient!")
    else:
        user_ingredients = parse_ingredients(user_input)

        st.success(f"Found {len(user_ingredients)} ingredients: {', '.join(user_ingredients)}")

        with st.spinner("Searching recipe database..."):
            query = f"recipes using {', '.join(user_ingredients)}"
            docs = vectorstore.similarity_search(query, k=num_recipes * 2)

            recipes = []
            seen_names = set()

            for doc in docs:
                recipe = extract_recipe_details(doc.page_content)
                if recipe["name"] and recipe["name"] not in seen_names:
                    # Check if user has at least one ingredient for this recipe
                    missing = calculate_missing_ingredients(user_ingredients, recipe["ingredients"])
                    if len(missing) < len(recipe["ingredients"]):  # Has at least 1 match
                        recipes.append(recipe)
                        seen_names.add(recipe["name"])
                        if len(recipes) >= num_recipes:
                            break

        if not recipes:
            st.error("No recipes found. Try different ingredients!")
        else:
            st.divider()
            st.subheader(f"üçΩÔ∏è Top {len(recipes)} Recipe Suggestions")

            all_missing = {}

            for i, recipe in enumerate(recipes, 1):
                with st.expander(f"**{i}. {recipe['name']}** (Servings: {recipe['servings']})", expanded=(i==1)):
                    st.markdown("**Ingredients:**")
                    missing = calculate_missing_ingredients(user_ingredients, recipe["ingredients"])

                    for ing in recipe["ingredients"]:
                        if ing in missing:
                            st.markdown(f"- ‚ùå {ing}")
                            all_missing[ing] = all_missing.get(ing, 0) + 1
                        else:
                            st.markdown(f"- ‚úÖ {ing}")

                    st.markdown("**Instructions:**")
                    st.write(recipe["instructions"])

                    if not missing:
                        st.success("‚ú® You have all ingredients for this recipe!")

            st.divider()
            st.subheader("üõí Shopping List")

            if all_missing:
                st.markdown("Based on the recipes above, you're missing:")

                sorted_missing = sorted(all_missing.items(), key=lambda x: x[1], reverse=True)

                for ingredient, count in sorted_missing:
                    st.markdown(f"- **{ingredient}** (needed for {count} recipe{'s' if count > 1 else ''})")

                with st.spinner("Generating shopping tips..."):
                    ingredients_list = ', '.join([i[0] for i in sorted_missing[:3]])
                    tip_prompt = f"Question: What is a helpful tip for shopping for {ingredients_list} at the grocery store? Answer:"
                    tip = generate_with_flan(tip_prompt, max_tokens=80)

                    if tip and len(tip) > 10:
                        st.info(f"üí° **Shopping Tip:** {tip}")
            else:
                st.success("üéâ You have all the ingredients needed for these recipes!")

st.divider()
st.caption("ü§ñ Powered by FLAN-T5 and Sentence Transformers")
"""

with open("app.py", "w") as f:
    f.write(app_code)

# 3) Kill anything on 8501 and start Streamlit
!pkill -f streamlit || true
!fuser -k 8501/tcp || true
!streamlit run app.py --server.port 8501 --server.headless true &>/dev/null&

# 4) Open a Cloudflare tunnel and print the URL
import subprocess, time

!wget -q -O cloudflared https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
!chmod +x cloudflared

p = subprocess.Popen(
    ["./cloudflared", "tunnel", "--url", "http://localhost:8501", "--no-autoupdate"],
    stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
)

url = None
for _ in range(300):
    line = p.stdout.readline()
    if not line:
        time.sleep(0.1)
        continue
    if "trycloudflare.com" in line:
        for token in line.split():
            if token.startswith("https://") and "trycloudflare.com" in token:
                url = token.strip()
                break
    if url:
        break

print("üç≥ Recipe Builder URL:", url if url else "Still starting... check the logs above.")

!pip install streamlit langchain-community faiss-cpu sentence-transformers \
            transformers accelerate safetensors pypdf -q

# =========================
# üç≥ Recipe Builder RAG ‚Äî Launcher
# =========================

# 1) Install deps
!pip -q install streamlit langchain-community faiss-cpu sentence-transformers \
                transformers accelerate safetensors requests > /dev/null

# 2) Write the Streamlit app
app_code = """
import torch
import streamlit as st
import requests
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from langchain.text_splitter import RecursiveCharacterTextSplitter
from transformers import AutoTokenizer, AutoModelForSeq2SeqLM

st.set_page_config(page_title="Recipe Builder", page_icon="üç≥")
st.title("üç≥ AI Recipe Builder with Shopping List")

st.markdown(
    "Enter the ingredients you have, and I'll suggest recipes you can make "
    "plus a shopping list for any missing items!"
)

# ---------------------------
# FETCH RECIPES FROM TheMealDB
# ---------------------------
@st.cache_data(ttl=3600)
def fetch_recipes_from_mealdb():
    recipes_text = []

    # Fetch recipes by different categories
    categories = ['Seafood', 'Chicken', 'Beef', 'Pasta', 'Vegetarian', 'Dessert', 'Breakfast', 'Pork', 'Lamb']

    with st.spinner("Loading recipes from TheMealDB..."):
        for category in categories:
            try:
                response = requests.get(f"https://www.themealdb.com/api/json/v1/1/filter.php?c={category}", timeout=10)
                if response.status_code == 200:
                    meals = response.json().get('meals', [])

                    for meal in meals[:15]:  # Get first 15 from each category
                        meal_id = meal['idMeal']

                        # Get full recipe details
                        detail_response = requests.get(f"https://www.themealdb.com/api/json/v1/1/lookup.php?i={meal_id}", timeout=10)
                        if detail_response.status_code == 200:
                            meal_data = detail_response.json().get('meals', [])[0]

                            # Extract ingredients
                            ingredients = []
                            for i in range(1, 21):
                                ingredient = meal_data.get(f'strIngredient{i}', '').strip()
                                measure = meal_data.get(f'strMeasure{i}', '').strip()
                                if ingredient:
                                    ingredients.append(ingredient.lower())

                            # Format recipe
                            instructions = meal_data.get('strInstructions', '').strip()
                            if not instructions:
                                instructions = "Instructions not available for this recipe."

                            recipe_text = f'''
Recipe: {meal_data['strMeal']}
Ingredients: {', '.join(ingredients)}
Instructions: {instructions}
Category: {meal_data['strCategory']}
Servings: 4
'''
                            recipes_text.append(recipe_text)
            except Exception as e:
                st.warning(f"Could not fetch {category} recipes: {e}")
                continue

    return '\\n'.join(recipes_text)

# ---------------------------
# CACHED MODELS
# ---------------------------
@st.cache_resource
def load_embeddings():
    return HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")

@st.cache_resource
def load_flan():
    name = "google/flan-t5-base"
    tok = AutoTokenizer.from_pretrained(name)
    dtype = torch.float16 if torch.cuda.is_available() else torch.float32
    model = AutoModelForSeq2SeqLM.from_pretrained(name, torch_dtype=dtype)
    device = "cuda" if torch.cuda.is_available() else "cpu"
    model.to(device)
    return tok, model, device

@st.cache_resource
def build_recipe_vectorstore():
    recipe_db = fetch_recipes_from_mealdb()

    if not recipe_db:
        st.error("Failed to load recipes from TheMealDB. Please refresh the page.")
        st.stop()

    embeddings = load_embeddings()
    splitter = RecursiveCharacterTextSplitter(
        chunk_size=500,
        chunk_overlap=50,
        separators=["\\n\\nRecipe:", "\\n"],
    )
    docs = splitter.create_documents([recipe_db])
    return FAISS.from_documents(docs, embeddings)

# Load models
embeddings = load_embeddings()
tokenizer, flan, device = load_flan()
vectorstore = build_recipe_vectorstore()

# ---------------------------
# HELPERS
# ---------------------------
def parse_ingredients(user_input):
    ingredients = [i.strip().lower() for i in user_input.replace("\\n", ",").split(",")]
    return [i for i in ingredients if i]

def extract_recipe_details(recipe_text):
    lines = recipe_text.strip().split("\\n")
    recipe = {"name": "", "ingredients": [], "instructions": "", "servings": ""}

    i = 0
    while i < len(lines):
        line = lines[i]
        if line.startswith("Recipe:"):
            recipe["name"] = line.replace("Recipe:", "").strip()
        elif line.startswith("Ingredients:"):
            ingredients = line.replace("Ingredients:", "").strip()
            recipe["ingredients"] = [ing.strip() for ing in ingredients.split(",")]
        elif line.startswith("Instructions:"):
            # Get everything after "Instructions:" on this line
            instruction_text = line.replace("Instructions:", "").strip()
            # Continue reading lines until we hit another field or end
            i += 1
            while i < len(lines) and not lines[i].startswith(("Recipe:", "Category:", "Servings:")):
                instruction_text += " " + lines[i].strip()
                i += 1
            recipe["instructions"] = instruction_text
            continue  # Skip the i += 1 at the end since we already incremented
        elif line.startswith("Servings:"):
            recipe["servings"] = line.replace("Servings:", "").strip()
        i += 1

    # Fallback if instructions are empty
    if not recipe["instructions"]:
        recipe["instructions"] = "Instructions not available for this recipe."

    return recipe

def calculate_missing_ingredients(user_ingredients, recipe_ingredients):
    user_set = set(user_ingredients)
    missing = []

    for ingredient in recipe_ingredients:
        ingredient_lower = ingredient.lower()
        if not any(user_ing in ingredient_lower or ingredient_lower in user_ing
                   for user_ing in user_set):
            missing.append(ingredient)

    return missing

def generate_with_flan(prompt, max_tokens=256):
    inputs = tokenizer(prompt, return_tensors="pt", truncation=True, max_length=512).to(device)
    with torch.no_grad():
        output = flan.generate(
            **inputs,
            max_new_tokens=max_tokens,
            temperature=0.7,
            do_sample=True,
            top_p=0.9,
            repetition_penalty=1.5,
        )
    return tokenizer.decode(output[0], skip_special_tokens=True)

# ---------------------------
# UI
# ---------------------------
st.subheader("üìù Enter Your Ingredients")

user_input = st.text_area(
    "List the ingredients you have (comma or line separated)",
    placeholder="e.g., chicken, rice, onion, garlic, soy sauce",
    height=100
)

num_recipes = st.slider("Number of recipes to generate", 3, 10, 5)

if st.button("üîç Find Recipes", type="primary"):
    if not user_input.strip():
        st.warning("Please enter at least one ingredient!")
    else:
        user_ingredients = parse_ingredients(user_input)

        st.success(f"Found {len(user_ingredients)} ingredients: {', '.join(user_ingredients)}")

        with st.spinner("Searching recipe database..."):
            query = f"recipes using {', '.join(user_ingredients)}"
            docs = vectorstore.similarity_search(query, k=num_recipes * 3)

            recipes = []
            seen_names = set()

            for doc in docs:
                recipe = extract_recipe_details(doc.page_content)
                if recipe["name"] and recipe["name"] not in seen_names:
                    # Check if user has at least one ingredient for this recipe
                    missing = calculate_missing_ingredients(user_ingredients, recipe["ingredients"])
                    if len(missing) < len(recipe["ingredients"]):  # Has at least 1 match
                        recipes.append(recipe)
                        seen_names.add(recipe["name"])
                        if len(recipes) >= num_recipes:
                            break

        if not recipes:
            st.error("No recipes found with your ingredients. Try different or more common ingredients!")
        else:
            st.divider()
            st.subheader(f"üçΩÔ∏è Top {len(recipes)} Recipe Suggestions")

            all_missing = {}

            for i, recipe in enumerate(recipes, 1):
                with st.expander(f"**{i}. {recipe['name']}** (Servings: {recipe['servings']})", expanded=(i==1)):
                    st.markdown("**Ingredients:**")
                    missing = calculate_missing_ingredients(user_ingredients, recipe["ingredients"])

                    for ing in recipe["ingredients"]:
                        if ing in missing:
                            st.markdown(f"- ‚ùå {ing}")
                            all_missing[ing] = all_missing.get(ing, 0) + 1
                        else:
                            st.markdown(f"- ‚úÖ {ing}")

                    st.markdown("**Instructions:**")
                    st.write(recipe["instructions"])

                    if not missing:
                        st.success("‚ú® You have all ingredients for this recipe!")

            st.divider()
            st.subheader("üõí Shopping List")

            if all_missing:
                st.markdown("Based on the recipes above, you're missing:")

                sorted_missing = sorted(all_missing.items(), key=lambda x: x[1], reverse=True)

                for ingredient, count in sorted_missing:
                    st.markdown(f"- **{ingredient}** (needed for {count} recipe{'s' if count > 1 else ''})")

                with st.spinner("Generating shopping tips..."):
                    ingredients_list = ', '.join([i[0] for i in sorted_missing[:3]])
                    tip_prompt = f"Question: What is a helpful tip for shopping for {ingredients_list} at the grocery store? Answer:"
                    tip = generate_with_flan(tip_prompt, max_tokens=80)

                    if tip and len(tip) > 10:
                        st.info(f"üí° **Shopping Tip:** {tip}")
            else:
                st.success("üéâ You have all the ingredients needed for these recipes!")

st.divider()
st.caption("ü§ñ Powered by TheMealDB, FLAN-T5, and Sentence Transformers")
"""

with open("app.py", "w") as f:
    f.write(app_code)

# 3) Kill anything on 8501 and start Streamlit
!pkill -f streamlit || true
!fuser -k 8501/tcp || true
!streamlit run app.py --server.port 8501 --server.headless true &>/dev/null&

# 4) Open a Cloudflare tunnel and print the URL
import subprocess, time

!wget -q -O cloudflared https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
!chmod +x cloudflared

p = subprocess.Popen(
    ["./cloudflared", "tunnel", "--url", "http://localhost:8501", "--no-autoupdate"],
    stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
)

url = None
for _ in range(300):
    line = p.stdout.readline()
    if not line:
        time.sleep(0.1)
        continue
    if "trycloudflare.com" in line:
        for token in line.split():
            if token.startswith("https://") and "trycloudflare.com" in token:
                url = token.strip()
                break
    if url:
        break

print("üç≥ Recipe Builder URL:", url if url else "Still starting... check the logs above.")